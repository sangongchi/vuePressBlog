---
title: 计算机网络原理
date: 2020-07-23
sidebar: autoS
tags:
  - 计算机网络
categories:
  - 计算机基础知识

---



## 网络-计算机 问题

###  计算机七层模型（分别是做什么的）

#### 七层模型图

![1594738213564](H:\biji\typora_imgs\1594738213564.png)

#### 1. 物理层

- 设备：电缆、双绞线、无线网（电磁微波）、中继器、集线器。
- 功能：实现0、1信号的传输。这些0、1信号就是计算机能够识别的数据。

#### 2. 数据链路层

  经物理层传输后，接收到信号如下： 0000011110000010101010011110

  问题：看得懂吗？谁送的信号？送给谁？因此，我们需要有一个规定（协议）来说明怎么我们该怎么编制有用的信号，然后大家就照这个来。
  涉及硬件：网桥、网卡、以太网交换机

##### 2.1 以太网协议

以太网协议就是来解决上面问题的。他规定一个数据包（帧）应该包含以下内容：

![1594739235651](H:\biji\typora_imgs\1594739235651.png)

一个电信号就是一个比特位。
地址：以太网帧中，目的地址与源地址这里都指的是 MAC 地址（Media Access Control Address）。每一个主机都有网卡接口，网卡会产生一个 MAC 地址，该地址由供应商代码和序列号组成（参考），长度是 48 位，所以这里的目的地址与源地址都是 6 个字节，也就是 48 个比特位。
数据质量：在以太网帧的最后，是一个 CRC 校验码，来校验数据是否异常。
向上交付时的协议：在中间，有一个两个字节的类型标识。这个类型字段有三种值，分别是 ： IP、ARP、RARP，对应的是向上层交付时采用的协议（上一层怎么读懂我）。

问题：虽然有地址，但发出时是以广播的形式发出，即所有连着的计算机都可能收到信号，怎么办？另：如果A计算机要给B发消息，那A怎么知道B的地址呢？

##### 2.2 广播与ARP协议

  广播：计算机以广播的形式发出信号，所有连着的计算机都可能受到信号，这是接受到信号的计算机判断目的地址是不是自己。是，则接受；否，则丢弃。就像在广场上，有人大呼某个人的名字，你听到了，则判断如果是你，则回应，否则，就当没听见。
  ARP协议：计算机 A 是如何知道计算机 B 的 MAC 地址的呢？这个时候就得由 ARP 协议这个家伙来解决了，不过 ARP 协议会涉及到IP地址，我们下面才会扯到IP地址。因此我们先放着，就当作是有这么一个 ARP 协议，通过它我们可以知道子网中其他计算机的 MAC 地址。

  此外，为了明晰整个思路，在这里要思考下（虽然下面也有提到）：有了MAC地址（按照2.2.1可知它唯一标志了一台计算机），计算机不就可以通过它来通信了吗，为什么还有IP地址？答案是MAC确实可以通信了，但是仅限于在一个子网（局域网）中。利用IP地址的理念可将主机划分在不同的子网中，主机只会收到子网内的广播信息。否则，计算机会收到全世界的主机广播而来的数据，这样但是判断每个数据是否发给自己，都要忙死了，效率会十分低下。
  另一个值得思考的问题是：IP地址也可以唯一标识一台主机，那么是不是因为有了IP，那么MAC地址就显得多余呢？答案可以在有了 IP 地址，为什么还要用 MAC 地址？ - 向往美的回答 - 知乎里找到。简单来说，IP（因特网）并没有定义底层的通信协议。由于历史的原因，局域网（以太网）是先于因特网存在的。因特网中，如IP等更高层的协议出现，目的是不让主机的通信紧紧局限于局域网中，而要让世界范围内的主机都可以通信。因此，因特网实际也包含了以太网协议，没有必要因为IP的出现而废止掉以太网协议，在以太网基础上构建因特网就可以了。IP地址和MAC地址之间的翻译是通过2.3.2中的ARP协议实现的。

PS：数据链路层主要涉及以太网协议和ARP协议，最常用的实现这些协议的硬件和软件是网络适配器。

#### 3 网络层

  网络层涉及硬件、软件：路由器（有内置软件）、三层交换机。路由器将局域网和广域网相连，实现不同网络间的通信，根据路由选择协议（Routing Protocol）提供的功能，它可以自动学习和记忆网络运行情况，在需要时自动计算数据传输的最佳路径(参考：路由器和网关的区别)。
  网络层有以下协议：Internet协议（IP）、nternet控制信息协议（ICMP）、址解析协议（ARP）、反向地址解析协议（RARP）（主机可以发送MAC地址给局域网内的RARP服务器，以请求对应的IP地址，若RARP列表中有该MAC地址，则返回IP供其使用，反之，则主机没有IP地址可用——ARP与RARP）。

  实际上，广播时只有同一个子网中的计算机能收到，而互联网实际上是由无数个子网组成的。
   为什么要有子网？ 这样划分很有好处，否则全世界无数的计算机都会收到数据包，光是判断这个数据包的工作量无法忍受。
  进一步，怎么区分MAC地址是否为同一个子网？解决方案是使用IP协议。

##### 3.1 IP协议

  IP协议规定的是数据报，其信息如下：

![1594739310456](H:\biji\typora_imgs\1594739310456.png)

  数据报中包含IP协议版本、IP header的长度、服务类型(最小延时，最大传输，最大可靠性，最小消耗等)、整个数据报字节数、识别号……源IP地址、目标IP地址。
  IP协议定义的地址称为IP地址。目前有两种版本，一种是IPv4（地址长度32位），另一种是IPv6，IPv6版本可以提供更多的地址（地址长度128位——IPV4与IPV6的区别（史上最详细））。目前主要是IPv4，因此下面主要讨论IPv4。
  IPv4由32位二进制数组成，一般将其分为四段十进制来表示。地址范围为：0.0.0.0~255.255.255.255 。
  IP地址怎么帮我们找到一个设备（计算机）呢？实际上IP地址给出了计算机的两部分信息：1、网络部分，给出计算机所处的子网；2、主机部分计算机的主机地址。
  那进一步这两个部分分别对应哪些二进制位数呢？实际上这两个部分所占的二进制位数并是不固定的。因为我们可以根据子网的规模合理分配IP地址。比如一个少于255台主机的子网主机部分只需占8位就够了，如果占了16位，则很多地址都不会被用到，这是极大的浪费。
  那我怎么知道网络部分和主机部分分别占几位呢？解决方案是引入子网掩码，他也是32位二进制数，并规定网络部分全为1，主机部分全为0。比如，主机部分为8位时，则对应的子网掩码是：
  11111111.11111111.11111111.00000000，即255.255.255.0。

![1594739321777](H:\biji\typora_imgs\1594739321777.png)

  有了子网掩码，就知道了哪些是网络部分，进而只需要把两个IP地址网络部分的网络部分对比，就知道是否在同一个子网中。

##### 3.2 ARP协议

  现在知道了IP协议，回头说ARP协议。之前说了他是用来得到同一个子网中目标计算机的MAC 地址，怎么实现呢？ MAC地址是数据链路层的通信协议所需要的，ARP的作用也相当于通过IP来获取MAC地址。
  ARP协议也是通过广播形式发送数据包给子网中所有计算机，数据包中含有目标计算机B的IP地址（不是MAC地址）。所有收到数据包的计算机会比较该IP地址和自己是否一致。如果一致，就回复给源计算机A自己的MAC地址（该地址唯一标志了主机的网卡接口）。否则丢弃该数据包。
  有一个问题：其他计算机怎么知道你想要传数据还是想询问MAC地址？e解决方法：ARP协议中的数据包中在对方的MAC地址这一栏中，填的是一个特殊的MAC地址，其他计算机看到这个特殊的MAC地址就知道是想干嘛了。

  那如果不是同一个子网，怎么发数据包给对方呢？ 假如两台计算机的IP不是处于同一个子网之中，这个时候，我们就会把数据包发送给网关，然后让网关让我们进行转发传送。

##### 3.3 DNS服务器

  我们一般不直接输入对方的IP地址，而是输入对方的域名（更好记的地址），DNS服务器通过解析域名来帮我们找到对应的IP地址。
  那么问题是：我们是如何知道对方计算机的IP地址的呢？ 这个问题可能有人会觉得很白痴，心想，当然是计算机的操作者来进行输入了。这没错，当我们想要访问某个网站的时候，我们可以输入IP来进行访问，但是我相信绝大多数人是输入一个网址域名的，例如访问百度是输入 http://www.baidu.com 这个域名。其实当我们输入这个域名时，会有一个叫做DNS服务器的家伙来帮我们解析这个域名，然后返回这个域名对应的IP给我们的。

#### 4 传输层

- 传输层涉及硬件：四层交换机、四层路由器。交换机和路由器都有相应的内置软件，来实现对应层网络的连接和数据传输、转发。
- 经过前面几层，我们已经知道如何把数据从计算机A发给计算机B。而一台计算机中的应用程序众多，我们怎么知道数据给哪一个应用呢？这个时候就需要用到传输层最常见的两大协议是:TCP 协议和 UDP 协议，两者最大的不同就是 TCP 提供可靠的传输，而 UDP 提供的是不可靠传输。

下面TCP和UDP的解释来自TCP 和 UDP 的区别、网络协议端口号详解以及简述TCP的三次握手过程

##### 4.1 UDP

UDP的包头如下：

![1594739355145](H:\biji\typora_imgs\1594739355145.png)

包头中的内容：由上图可以看出，UDP最重要的信息就是端口号。如果把IP地址比作一间房子 ，端口就是出入这间房子的门。真正的房子只有几个门，但是一个IP地址的端口 可以有65536（即：256×256）个之多！端口是通过端口号来标记的，端口号只有整数，范围是从0 到65535（256×256）。
收发端口：接受数据报的进程和发送数据报的进程都需要开启端口，因此数据报中将会标识有源端口，以便接受方能顺利的回传数据报到这个端口。
端口是一个队，操作系统为各个进程分配了不同的队，数据报按照目的端口被推入相应的队中，等待被进程取用，在极特殊的情况下，这个队也是有可能溢出的，不过操作系统允许各进程指定和调整自己的队的大小。

1. UDP的特点：
    - 结构简单，因此沟通简单。不建立连接，但会监听这个端口，因此可以多对多的收发数据。不会进行拥塞控制，无论是否丢包，只顾发送。

2. UDP的优势：
    - 需求资源少，不必建立一对一连接。对丢包不敏感的应用，或者需要处理速度快的。应用可用之。
        无需建立连接，可以承担广播或者多播的任务。
        UDP的例子：直播、实时游戏、物联网。


##### 4.2 TCP

TCP 的包头格式如下：

![1594740321143](H:\biji\typora_imgs\1594740321143.png)

其中包含如下内容：

- 首先，源端口和目标端口是不可少的。
- 序号：Seq序号，主要是为了解决乱序问题。不编好号怎么知道哪个先来，哪个后到
- 确认序号：Ack序号，发出去的包应该有确认，这样能知道对方是否收到，如果没收到就应该重新发送，这个解决的是不丢包的问题
- 状态位：共6个，即URG、ACK、PSH、RST、SYN、FIN等，具体含义如下：
    （A）URG：紧急指针是否有效。若为1，表示某一位需要被优先处理。
    （B）ACK：确认序号是否有效。
    （C）PSH：提示接收端应用程序立即从TCP缓冲区把该数据读走。
    （D）RST：对方要求重新建立连接，复位。
    （E）SYN：置为1时发起一个新连接。
    （F）FIN：置为1时，释放一个连接。
    因为 TCP 是面向连接的，因此需要双方维护连接的状态，这些状态位的包会引起双方的状态变更
    窗口大小，TCP 要做流量控制，需要通信双方各声明一个窗口，标识自己当前的处理能力。
    TCP协议应该关注的问题
- 通过对 TCP 头的解析，我们知道要掌握 TCP 协议，应该重点关注以下问题：顺序问题、丢包问题、连接维护、流量控制、拥塞控制
- TCP 的三次握手
    关于三次握手、四次挥手强烈建议看这篇文章：TCP的三次握手与四次挥手理解及面试题（很全面）

a.建立连接
  所谓三次握手（Three-Way Handshake）即建立TCP连接，就是指建立一个TCP连接时，需要客户端和服务端总共发送3个包以确认连接的建立。整个流程如下图所示：

![1594739538602](H:\biji\typora_imgs\1594739538602.png)

（1）第一次握手：Client将报文的标志位SYN置为1，随机产生一个序号seq=J，并将该数据包发送给Server，Client进入SYN_SENT状态，等待Server确认。
（2）第二次握手：Server收到数据包后，由报文中的标志位SYN=1知道Client在请求建立连接；Server会发送一个报文，其中标志位SYN和ACK都置为1，确认序号为ack=J+1，随机产生一个值seq=K（这样可避免黑客很容易猜到序列号而发起攻击），并将该数据包发送给Client以确认连接请求，Server进入SYN_RCVD状态。
（3）第三次握手：Client收到确认报文后，检查ack是否为J+1，ACK是否为1，如果正确，则再次发送一个报文，将标志位ACK置为1，ack=K+1，并将该数据包发送给Server，Server检查ack是否为K+1，ACK是否为1，如果正确则连接建立成功，Client和Server进入ESTABLISHED状态，完成三次握手，随后Client与Server之间可以开始传输数据了。
需要注意的是：
（A）不要将确认序号ack与标志位中的ACK搞混了。
（B）确认方确认序号ack=发起方序号seq+1，两端配对
SYN攻击：
在三次握手过程中，Server发送SYN-ACK之后，收到Client的ACK之前的TCP连接称为半连接（half-open connect），此时Server处于SYN_RCVD状态，当收到ACK后，Server转入ESTABLISHED状态。SYN攻击就是Client在短时间内伪造大量不存在的IP地址，并向Server不断地发送SYN包，Server回复确认包，并等待Client的确认，由于源地址是不存在的，因此，Server需要不断重发直至超时，这些伪造的SYN包将长时间占用未连接队列，导致正常的SYN请求因为队列满而被丢弃，从而引起网络堵塞甚至系统瘫痪。SYN攻击是一种典型的DDOS攻击，检测SYN攻击的方式非常简单，即当Server上有大量半连接状态且源IP地址是随机的，则可以断定遭到SYN攻击了，使用如下命令可以让之现行：
#netstat -nap | grep SYN_RECV

TCP的四次挥手
  所谓四次挥手（Four-Way Wavehand）即终止TCP连接，就是指断开一个TCP连接时，需要客户端和服务端总共发送4个包以确认连接的断开。在socket编程中，这一过程由客户端或服务端任一方执行close来触发，整个流程如下图所示(图源：TCP的三次握手与四次挥手理解及面试题（很全面）)：

![1594739557464](H:\biji\typora_imgs\1594739557464.png)

由于TCP连接是全双工的，因此，每个方向都必须要单独进行关闭，这一原则是当一方完成数据发送任务后，发送一个FIN报文来终止这一方向的连接，收到一个FIN报文只是意味着这一方向上没有数据流动了，即不会再收到数据了，但是在这个TCP连接上仍然能够发送数据，直到这一方向也发送了FIN。首先进行关闭的一方将执行主动关闭，而另一方则执行被动关闭，上图描述的即是如此。
（1）第一次挥手：Client发送一个FIN报文，其中FIN置为1，用来关闭Client到Server的数据传送，Client进入FIN_WAIT_1状态。
（2）第二次挥手：Server收到FIN报文后，发送一个ACK报文（ACK置为1）给Client，其中确认序号为收到序号+1（与SYN相同，一个FIN占用一个序号），Server进入CLOSE_WAIT状态。这时Client已不能发送数据，Server也不能接收Client的数据。但是Server还是可以给Client发数据，Client也还可以接收数据。
（3）第三次挥手：若Server发送一个FIN报文，用来关闭Server到Client的数据传送，则Server进入LAST_ACK状态。
（4）第四次挥手：Client收到FIN后，Client进入TIME_WAIT状态，接着发送一个ACK给Server，确认序号为收到序号+1，Server进入CLOSED状态，完成四次挥手。
上面是一方主动关闭，另一方被动关闭的情况，实际中还会出现同时发起主动关闭的情况，具体流程如下图：

![1594739573232](H:\biji\typora_imgs\1594739573232.png)

流程和状态在上图中已经很明了了，在此不再赘述，可以参考前面的四次挥手解析步骤。
顺序问题、丢包问题、流量控制、拥塞控制

TCP的面试题
关于三次握手与四次挥手通常都会有典型的面试题，在此提出供有需求的XDJM们参考：
（1）三次握手是什么或者流程？四次握手呢？答案前面分析就是。
（2）为什么建立连接是三次握手，而关闭连接却是四次挥手呢？
这是因为服务端在LISTEN状态下，收到建立连接请求的SYN报文后，Server可以把ACK和SYN同时置为1，放在一个报文里发送给客户端。而关闭连接时，当收到对方的FIN报文时，仅仅表示对方不再发送数据了但是还能接收数据，己方也未必全部数据都发送给对方了，所以己方可以立即close，也可以发送一些数据给对方后，再发送FIN报文给对方来表示同意现在关闭连接，因此，己方ACK和FIN一般都会分开发送

#### 5 应用层

  应用层这一层最接近我们用户了，虽然我们收到了传输层传来的数据，可是这些传过来的数据五花八门，有html格式的，有mp4格式的，各种各样。你确定你能看的懂？因此我们需要指定这些数据的格式规则，收到后才好解读渲染。 例如我们最常见的 Http 数据包中，就会指定该数据包是什么格式的文件了。
应用层主要有以下协议：

1、超文本传输协议（HTTP）:万维网的基本协议；
2、文件传输（TFTP简单文件传输协议）；
3、远程登录（Telnet），提供远程访问其它主机功能, 它允许用户登录internet主机，并在这台主机上执行命令；
4、网络管理（SNMP简单网络管理协议），该协议提供了监控网络设备的方法， 以及配置管理,统计信息收集,性能管理及安全管理等；
5、域名系统（DNS），该系统用于在internet中将域名及其公共广播的网络节点转换成IP地址。

#### 应用层到链路成数据如何传输

- 数据的封装，每一层在接收上一层数据时，都会添加特定的头部数据（有时候会有尾部数据）

![1594738315412](H:\biji\typora_imgs\1594738315412.png)





*原文链接*：https://blog.csdn.net/liuchengzimozigreat/java/article/details/100169829

###  AMD 、CMD、ES6 Module、CommonJS

#### 1. AMD 推崇依赖前置，在定义模块的时候就要声明器依赖的模块

- 一般的 AMD 指 RequireJS

    ```JS
    //通过 define 来定义一个模块，使用 require 可以导入定义的模块
    
    //a.js
    //define可以传入三个参数，分别是字符串-模块名、数组-依赖模块、函数-回调函数
    define(function(){
        return 1;
    })
    
    // b.js
    //数组中声明需要加载的模块，可以是模块名、js文件路径
    require(['a'], function(a){
        console.log(a);// 1
    });
    ```

    

#### 2. CMD 推崇就近依赖，只要用到某个模块的时候再去require

- CMD是 SeaJS 过程产生的

    ```js
    //SeaJS的 基本用法
    
    /*
    * define 接受 factory 参数，factory 可以是一个函数，也可以是一个对象或字符串，
    * factory 为对象、字符串时，表示模块的接口就是该对象、字符串。
    * define 也可以接受两个以上参数。字符串 id 表示模块标识，数组 deps 是模块依赖.
    */
    define(function(require, exports, module) {
      var $ = require('jquery');
    
      exports.setColor = function() {
        $('body').css('color','#333');
      };
    });
    
    //b.js
    //数组中声明需要加载的模块，可以是模块名、js文件路径
    seajs.use(['a'], function(a) {
      $('#el').click(a.setColor);
    });
    ```

    

#### 3. CommonJS

```js
//a.js
module.exports = function () {
  console.log("hello world")
}

//b.js
var a = require('./a');

a();//"hello world"

//或者

//a2.js
exports.num = 1;
exports.obj = {xx: 2};

//b2.js
var a2 = require('./a2');

console.log(a2);//{ num: 1, obj: { xx: 2 } }
```

#### 4. ES6 Module的基本用法

```js
//a.js
var name = 'lin';
var age = 13;
var job = 'ninja';

export { name, age, job};

//b.js
import { name, age, job} from './a.js';

console.log(name, age, job);// lin 13 ninja

//或者

//a2.js
export default function () {
  console.log('default ');
}

//b2.js
import customName from './a2.js';
customName(); // 'default'
```

目前浏览器对`ES6 Module` 兼容性还不太好，我们 平时在`webpack` 中使用 `export/import`,会被打包为`exports/require`

*参考*：https://juejin.im/post/5db95e3a6fb9a020704bcd8d

### http是无状态协议如何让他变为有状态的

- HTTP协议是无状态的，不会记录用户信息，使用 `Cookie`和`Session`可以让http变为有状态

#### Cookie

- `Cookie` 是客户端存储空间，由浏览器维持， 也就是cookie机制采用的是客户端保持状态的
- `Cookie`是服务器生成的（客户端会根据服务端发送的响应报文内的一个叫 Set-Cookie 的首部字段信息，通知客户端保存Cookie ，当下次客户端再往服务器发送请求时，客户端会自动在请求报文总加上 Cookie 值后发出去），发送给客户端，有客户端保存，每次请求加上 Cookie ,服务端发现客户端发送过来的 Cookie 后，会检查是从哪个客户端发送来的连接请求，对比服务器上的记录，最后得到状态信息。

#### Session

- Session 是记录客户状态的机制，不同于Cookie的是，Session 保存在服务器中，

> Cookie 和 Seesion 的应用场景
>
> 1. 登录网站，今天输入用户名和密码登录，
> 2. Seesion 一个场景是购物车，添加商品之后客户端可以知道添加了哪些商品，服务器判断，添加到Seesion中。

*参考*：https://blog.csdn.net/H_Expect/article/details/99967490

### http和https的区别以及实现原理

### CROS 和 XSS 攻击以及预防措施

#### 预防`XSS`攻击的方案：

- 对输入进行验证，比如常见的数字、`url`、电话号码、邮箱判断等等校验判断
- 对数据进行输出编码，`html`元素编码、`js`编码、`url`编码（尽量避免使用 `v-html`）
- 添加验证码操作
- 开始浏览器的`XSS` 防御，`cookie` 中设置`HttpOnly`属性 ，禁止 `JavaScript` 读取某些敏感 `Cookie`，攻击者完成 `XSS` 注入后也无法窃取此 `Cookie`。

### 进程和线程

#### 进程

- 进程`Process`是系统进行资源分配和调度的基本单位（最小单位），是操作系统结构的基础。**进程是线程的容器**
- 我们启动一个服务、运行一个实例就是开启一个服务进程，例如：Java 中的 JVM 本身就是一个进程， Node.js 里面通过 `node app.js` 开启一个服务进程，
- 多进程就是进程的复制（fork），fork 出来的每个进程都拥有自己独立的空间地址、数据栈、一个进程无法访问另一个进程里定义的变量、数据结构、只有建立了 IPC 通信，进程之间才可以数据共享。
- 浏览器是多进程的，每个tab页面都是一个进程，每个插件也是一个进程（在使用的时候开启一个进程）,GPU进程最多创建一个用于 3D 绘制。
    - Browser 进程是浏览器的主进程，主要负责协调和主控，仅有一个，作用是负责浏览器的界面显示，与用户交互前进、后退等
    - 负责各个页面的管理，创建销毁
    - 将 Renderer 进程得到的 Bitmap ，绘制到用户界面上
    - 网络资源的管理和下载等
- 浏览器的渲染进程（浏览器内核）Renderer 进程，内部是多线程的，默认每个 Tab 页面一个进程，互不影响，主要作用是：页面渲染，脚本执行，时间处理。

#### 线程

- 线程是操作系统能够调度的最小单位，**一个进程可以拥有多个线程，但是一个线程只能隶属于一个进程**

- **单线程**： 就是一个进程只开一个线程。（js 即单线程），当你使用 单线程语言编码的时候切勿有过多的同步操作，否则会造成线程堵塞。

    ```js
    //经典计算耗时造成线程堵塞的例子
    const http = require('http');
    const longComputation = () => {
      let sum = 0;
      for (let i = 0; i < 1e10; i++) {
        sum += i;
      };
      return sum;
    };
    const server = http.createServer();
    server.on('request', (req, res) => {
      if (req.url === '/compute') {
        console.info('计算开始',new Date());
        const sum = longComputation();
        console.info('计算结束',new Date());
        return res.end(`Sum is ${sum}`);
      } else {
        res.end('Ok')
      }
    });
    
    server.listen(3000);
    //打印结果
    //计算开始 2019-07-28T07:08:49.849Z
    //计算结束 2019-07-28T07:09:04.522Z
    
    
    ```

    根据以上情况，用户调用 `compute`的时候，想要调用其他路由地址大约需要15秒时间，对用户来说是极其不友好的。下文可尝试创建多进程的方式，来解决

- 当项目中有大量的计算，CPU 耗时操作的时候，要考虑开始多进程来完成了

- Node.js 虽然是单线程模型，但是其基于事件驱动、异步非阻塞模式，可以应用于高并发场景，避免了线程创建、线程之间上下文切换所产生的资源开销

- Node.js 开发过程中，错误会引起整个应用退出，应用的健壮性就值得考虑，尤其错误异常的抛出，以及进程的守护是必需要做得的。

- 单线程无法利用多核 CPU 但是后期 Node.js 提供一些 API 以及一些第三方工具得到了解决。在多核 CPU 系统之上，可以通过 `child_process.fork` 开启多个进程。注意：开启多进程不是为了解决高并发，主要解决了单进程模式下 Node.js CPU 利用率不足的情况，充分利用多核 CPU 的性能。

#### Node.js 中的进程

##### process 模块

- Node.js 中的进程 Process 是一个全局对象，无需 require 直接使用

    - `process.env`：环境变量，例如通过  `process.env.NODE_ENV` 获取不同环境项目配置信（==webpack 会将 `production`作为`mode`默认值设置==,当设置了模式以后，webpack 会自动为项目添加一些插件。）

    - `process.nextTick`：这个在谈及 `Event Loop` 时经常为会提到

    - `process.pid`：获取当前进程id

    - `process.ppid`：当前进程对应的父进程

    - `process.cwd()`：获取当前进程工作目录，

    - `process.platform`：获取当前进程运行的操作系统平台

    - `process.uptime()`：当前进程已运行时间，例如：pm2 守护进程的 uptime 值

        进程事件：`process.on(‘uncaughtException’, cb)` 捕获异常信息、`process.on(‘exit’, cb）`进程推出监听

        三个标准流：`process.stdout` 标准输出、`process.stdin` 标准输入、`process.stderr` 标准错误输出

        `process.title` 指定进程名称，有的时候需要给进程指定一个名称

#### 浏览器的渲染进程（Renderer）

1. GUI渲染进程
    - 负责渲染界面，解析 HTML,CSS,构建DOM 树，和RendererObject树，布局和绘制等
    - 当界面需要重绘（Repaint）或由于 某种操作引发回流*（reflow）时，该线程就会执行
    - GUI 渲染线程与 JS 迎请线程是互斥的，
2. JS 引擎线程
    - 也成 JS 内核，负责 javascript脚本程序
    - js 引擎负责解析执行 javascript 脚本，运行代码
    - 一个tab页，无论什么时候都只有一个 js线程在运行js程序
    - GUI渲染线程与js引擎线程是互斥的，所以js执行时间过长，这样就会造成页面的渲染不连贯没导致页面渲染加载阻塞
3. 事件触发线程
    - 归属于浏览器而不是 js 引擎，用来控制事件循环
    - 鼠标点击、ajax异步请求等
4. 定时触发线程
    - `setInterval`与`setTimeout`所在线程
    - 浏览器定时器并不是 javascript 引擎计数的
    - 浏览器通过单线程来记时并触发定时
5. 异步http请求线程
    - 在XMLHttpRequest 在连接后是通过浏览器新开一个线程请求
    - 检测到状态变更时，如果设置有回调函数，异步线程就**产生状态变更事件**，将这个回调再放入事件队列中。再由JavaScript引擎执行。

*参考链接*：<https://juejin.im/post/5d43017be51d4561f40adcf9>

### WebSockt 相关

### 浏览器的存储 Cookie、LocalStorage、SessionStorage、Session、IndexedDB

#### 1. Cookie

- Cookie 的主要功能并非本地存储，而是‘维持状态’，Cookie 值某网站为了辨别身份而存储在用户终端上的数据（通常是经过加密）。cookie是服务器生成，客户端进行维护和存储。
- 存储大小有限制 在 4k左右，以键值对的形式存在。
- 过多的 Cookie 会带来巨大的性能浪费，Cookie 是紧跟随域名的，统一域名下的所有请求都会携带 Cookie .对于静态文件的请求，携带 Cookie 信息根本没用，可以用过 cdn 存储静态文件的域名和主站域名分开。
- 可以设置过期时间

**Cookie 生成方式主要有两种**

- 生成方式一：

    - http response header 中的 set-cookie

    - 通过响应头里的 Set-Cookie 指定要存储的 Cookie 值。默认情况下，domain 被设置为设置 Cookie 页面的主机名，我们也可以手动设置 domain 的值。domain 标识制定了哪些域名可以接受Cookie，没有设置 domain ，就会自动绑定当前域。

    - ```js
        Set-Cookie: id=a3fWa; Expires=Wed, 21 Oct 2018 07:28:00 GMT;  HttpOnly
        //可以指定一个特定的过期时间（Expires）或有效期（Max-Age）
        // 使用 HttpOnly 设置浏览器不支持读写。
        ```

- 生成方式二：

    - `document.cookie="userName=hello"`

#### 2.LocalStorage（本地存储）

###### 特点：

- 保存的数据长期存在（除非用户手动清理客户端缓存），下一次访问该网站的时候，网页可以直接读取以前保存的数据（开发者可以自己设置一个方法，设置失效时间）
- 大小 5M 左右，仅在客户端使用，不和服务器进行通信
- 接口封装较好

##### 存入读取数据：

```js
// 保存数据到 localStorage

localStorage.setItem('key', 'value');

// 从 localStorage 获取数据

let data = localStorage.getItem('key');

// 从 localStorage 删除保存的数据

localStorage.removeItem('key');

// 从 localStorage 删除所有保存的数据

localStorage.clear();
```



#### 3.SessionStorage（会话存储）

- 数据保存在当前会话，刷新页面数据不会被清除，仅当前会话有效。结束会话（关闭浏览器、关闭页面、跳转页面）数据失效

```js
// 保存数据到 sessionStorage

sessionStorage.setItem('key', 'value');

// 从 sessionStorage 获取数据

let data = sessionStorage.getItem('key');

// 从 sessionStorage 删除保存的数据

sessionStorage.removeItem('key');

// 从 sessionStorage 删除所有保存的数据

sessionStorage.clear();
```

#### 4.Session

#### 5.IndexedDB

#### ==localStorage、sessionStorage、Cookie不同点:==

相同点：都保存浏览器端，且是同源。

> - 存储大小不同：
>     1. `localStorage` 的大小一般为`5M`
>     2. `sessionStorage` 的大小一般为 `5M`
>     3. `cookies` 的大小一般为 `4K`
>
> - 有效期不同
>     1. `localStorage` 的有效期永久有效，除非用户自己手动删除
>     2. `seesionStorage` 在当前会话有效，关闭页面或者浏览器时会被清空。
>     3. `cookies` 在设置的有效期之前有效，当超过有效期便会失效
> - 与服务端的通信
>     1. `localStorage` 不参与服务端的通信
>     2. `seesionStorage` 不参与服务端的通信
>     3. `cookies` 参与服务端通信会携带`http`的头信息。（如果使用`cookie`保存过多数据会带来性能问题）
> - 不同的浏览器无法共享 `localStorage` 或 `sesionStorage` 中的信息
> - 相同浏览器的不同页面可以共享相同的 `localStorage` ,但不同页面或标签无法贡献 `seesionStorage`

### 缓存相关

### webwork的作用

> 1. js是单线程的，为了JavaScript 创造多线程环境，

*参考*：http://www.ruanyifeng.com/blog/2018/07/web-worker.html





### Options 

Options 该方法常常用于请求服务器告知其支持哪些其它的功能和方法。

*参考*：https://blog.csdn.net/qizhiqq/article/details/71171916

### DNS解析原理

### TCP和UDP 协议的区别

### webkit  内核

*参考*： https://www.cnblogs.com/qq499194341/articles/2891954.html



### 浏览器的渲染进程





































